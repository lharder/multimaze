local Events = require( "level.playground.events" )
local lua = require( "deflibs.lualib" )

go.property( "speed", 0 )
go.property( "isLocalHero", false )


local MSG_ON_FIRST_TICK = hash( "firsttick" )


local function animWalk( self )
	local name = "standdown"

	if not self.animating then
		self.animating = true

		if math.abs( self.dir.x ) > math.abs( self.dir.y ) then 
			-- x-axis movement is more significant
			if self.dir.x > 0 then name = "walkright" .. self.animNo end
			if self.dir.x < 0 then name = "walkleft" .. self.animNo end
		else
			-- y-axis movement is more significant
			if self.dir.y > 0 then name = "walkup" .. self.animNo end
			if self.dir.y < 0 then name = "walkdown" .. self.animNo end
		end

		-- player is standing, but used to move
		if vmath.length( self.dir ) < 1 then
			self.animating = false

			if self.oldDir.x > 0 then name = "standright" end
			if self.oldDir.x < 0 then name = "standleft" end
			if self.oldDir.y > 0 then name = "standup" end
			if self.oldDir.y < 0 then name = "standdown" end
		end	

		sprite.play_flipbook( "#sprite", name, function( id, tileNo ) 
			self.animating = false
			self.animNo = 1 - self.animNo
		end )

	end
end


local function parse( self, message )
	if message.meta.type == Events.MOVE_TO then
		if message.attrs.pos then 
			self.oldDir = vmath.vector3( self.dir.x, self.dir.y, self.dir.z )
			
			-- Target's position is probably outdated when received here 
			-- already. To compensate, assume that target has continued to 
			-- move in the same direction: calcluate direction and add a
			-- custom factor depending on the network latency
			self.targetPos = message.attrs.pos
			self.dir = vmath.normalize( self.targetPos - self.pos )
			self.targetPos = self.targetPos + self.dir * self.speed * 0,07

			-- When moving into position diagonally, the remote object is 
			-- slower than the original. Apparently, the movement is "up" 
			-- then "right", not "up right" most of the times because
			-- of interpolation. Compensate by higher speed 
			-- (diagonal = 1.4 steps length instead of 1, Pythagoras... :o)
			if self.dir.x == 0 or self.dir.y == 0 then
				self.speed = self.origSpeed
			else
				self.speed = self.origSpeed * 1.4
			end

			-- adjust movement animation on change of direction
			animWalk( self )
		end
	end
end


-- methods ---------------------
function init( self )
	self.dir = vmath.vector3()
	self.oldDir = vmath.vector3()
	self.pos = go.get_position()
	self.origSpeed = self.speed

	self.animNo = 1
	self.animating = false

	msg.post( ".", MSG_ON_FIRST_TICK )
end


function update( self, dt )
	if self.targetPos then 
		-- Move towards a target in a straight line. Target is
		-- provided by remote player, this is only a drone gameobject
		self.pos = go.get_position()
		self.dir = vmath.normalize( self.targetPos - self.pos )
		self.pos.x = self.pos.x + self.dir.x * self.speed * dt
		self.pos.y = self.pos.y + self.dir.y * self.speed * dt
		go.set_position( self.pos )

		if 	lua.approximates( self.pos.x, self.targetPos.x, 2 ) and
			lua.approximates( self.pos.y, self.targetPos.y, 2 ) then	
			-- pprint( self.gid .. " reached pos" )
			go.set_position( self.targetPos )
			self.targetPos = nil
			self.dir.x = 0
			self.dir.y = 0
		end
	end
end


function on_message( self, message_id, message, sender )
	if message_id == MSG_ON_FIRST_TICK then 
		-- get my global id, does not work on init()
		-- cannot pass in string params on factory.create...
		self.gid = GAME.client.registry:getGlobalId( go.get_id() )

	elseif message_id == GAME.MSG_EXEC_CMD then 
		parse( self, message )
	end
end



