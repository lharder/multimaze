local Events = require( "level.playground.events" )
local lua = require( "deflibs.lualib" )

go.property( "dir", vmath.vector3() )
go.property( "speed", 0 )
go.property( "isLocalHero", false )


local GROUP_BUTTON = hash( "button" )
local GROUP_TREASURE = hash( "treasure" )
local GROUP_DOOR = hash( "door" )
local GROUP_OBSTACLES = hash( "obstacle" )
local GROUP_PLAYERS = hash( "player" )


local function animWalk( self )
	if not self.animating then
		self.animating = true

		local name = "walkdown"
		if self.dir.x > 0 then name = "walkright" end
		if self.dir.x < 0 then name = "walkleft" end
		
		sprite.play_flipbook( "#sprite", name, function( id, tileNo ) 
			self.animating = false
		end )

	end
end


local function animStand( self )
	if not self.animating then
		self.animating = true
		
		local name = "standdown"
		if self.dir.y > 0 then name = "standup" end
		if self.dir.y < 0 then name = "standdown" end
		if self.dir.x > 0 then name = "standright" end
		if self.dir.x < 0 then name = "standleft" end
		
		sprite.play_flipbook( "#sprite", name, function( id, tileNo ) 
			self.animating = false
		end )
	end
end


local function parse( self, message )
	if message.meta.type == Events.CREATE_SHOT then 
		local pos = go.get_position() + message.attrs.angle * 30
		local maxPos = message.attrs.maxPos
		-- make speed 10% faster than a local shot: 
		-- approximation to make up for network lag
		local cid = factory.create( "/factories#locallaserfactory", pos, nil, { 
			speed = 1.1 * 500, angle = message.attrs.angle,  maxPos = maxPos 
		}, .5 )
		GAME.client.registry:set( message.attrs.gid, cid )
	end
end


local function isFree( vDir, id )
	local pos = go.get_position( id )
	local other = pos + vDir
	local res = physics.raycast( pos, other, { GROUP_OBSTACLES, GROUP_PLAYERS } )
	return res == nil, res
end


-- methods ---------------------
function init( self )
	self.dir = vmath.vector3()
	self.animating = false
end


function update( self, dt )
	self.pos = go.get_position()
	animWalk( self )

	-- push a movable object obstacle away 
	-- (behave just like a localplayer next to an obstacle)
	local freeSide, obj = isFree( self.dir * 18 )
	if not freeSide then
		local p = go.get_position( obj.id )	
		-- but only if there is no additional obstacle beyond!
		if MAP:isPassable( p.x - obj.normal.x * 32, p.y ) and isFree( -32 * obj.normal, obj.id ) then 
			p.x = p.x - obj.normal.x 
			go.set_position( p, obj.id )
		end
	end
end


function on_message( self, message_id, message, sender )
	if message_id == GAME.MSG_EXEC_CMD then 
		parse( self, message )
		
	end
end



