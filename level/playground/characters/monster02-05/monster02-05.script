local lua = require( "deflibs.lualib" )
local Registry = require( "nexus.registry" )
local Events = require( "level.playground.events" )


go.property( "dir", vmath.vector3( 1, 0, 0 ) )
go.property( "speed", 200 )

local MSG_SET_PROPS = hash( "setProps" )



local function shoot( self )
	self.animating = true
	sprite.play_flipbook( "#sprite", "attack", function() 
		local speed = 400
		local pos = go.get_position() 
		pos.x = pos.x + self.dir.x * 45
		pos.y = pos.y + 24
		local cid = factory.create( "/factories#ballfactory", pos, nil, { 
			speed = speed,  dir = self.dir 
		}, .5 )

		-- make id globally available
		local shotGid = sprintf( "%s-%d", self.gid, math.random( 0, 999999 ) )
		GAME.client.registry:set( shotGid, cid )

		-- inform other clients
		local evt = Events.newCreateShot( self.gid, shotGid, self.dir, maxPos )
		GAME.client:sendToOtherClients( evt )

		sprite.play_flipbook( "#sprite", "reload", function() 
			sprite.play_flipbook( "#sprite", "walk", function() 
				self.animating = false
			end )
		end )
	end )
end



local function turn( self, xDir )
	sprite.set_hflip( "#sprite", xDir == 1 )
	self.dir.x = xDir
end


local function hunt( self, cid )
	self.hunting = cid
	self.speed = self.maxspeed
	if self.pos.x < self.playerPos.y then 
		turn( self, 1 )
	else
		turn( self, -1 )
	end
end


local function setup( self, message ) 
	if GAME:isServer() then
		-- make globally available and start syncing
		local gid = message.name
		local cid = go.get_id()
		GAME.client.registry:set( gid, cid )
		GAME:sync( gid ) 
	end
end


-- lifecycle methods ---------------------------
function init( self )
	go.set_scale( .5 )

	self.pos = go.get_position()
	go.set_position( vmath.vector3( self.pos.x, self.pos.y, .4 ) )

	self.maxspeed = self.speed
	self.pos = go.get_position()
	self.hunting = nil
	self.cooldown = 0
	
	turn( self, self.dir.x )

	-- walk animation may be interrupted any time
	self.animating = false
	sprite.play_flipbook( "#sprite", "walk" )
end


function update( self, dt ) 
	if self.hunting == nil then
		-- run sideways, turn at obstacle
		self.pos = go.get_position()
		self.side = self.pos.x + ( self.dir.x * 24 ) + ( self.dir.x * self.speed * dt )
		self.below = self.pos.y - 40
		if( MAP:isPassable( self.side, self.pos.y ) and
		  ( not MAP:isPassable( self.side, self.below ) ) ) then 
			self.pos.x = self.pos.x + ( self.dir.x * self.speed * dt )
		else
			self.dir.x = -self.dir.x
			turn( self, self.dir.x )
			if not self.animating then 
				sprite.play_flipbook( "#sprite", "walk" ) 
			end
		end
	 
		-- no target yet - find one :o)
		for i, gid in pairs( PLAYERS ) do
			self.playerCid = GAME.client.registry:getClientId( gid ) 
			
			if self.playerCid ~= nil then 
				self.playerPos = go.get_position( self.playerCid )	

				if lua.approximates( self.pos.y, self.playerPos.y, 10 ) then
					if MAP:isWalkable( self.pos.x, self.pos.y, self.playerPos.x ) then
						hunt( self, self.playerCid ) 
						
						-- always attack only one player:
						-- stop after finding one at proper position
						break 
					end
				end
			end
		end
		
	else
		self.pos = go.get_position()
		if( MAP:isPassable( self.side, self.pos.y ) and
		  ( not MAP:isPassable( self.side, self.below ) ) ) then 
			self.pos.x = self.pos.x + ( self.dir.x * self.speed * dt )
		end
		
		-- follow target that has been identified already
		self.playerPos = go.get_position( self.playerCid )
		if lua.approximates( self.pos.x, self.playerPos.x, 30 ) then 
			self.speed = 0
		else
			self.speed = self.maxspeed
			if self.pos.x < self.playerPos.x then
				turn( self, 1 )
			else
				turn( self, -1 )
			end
		end

		if not ( ( lua.approximates( self.pos.y, self.playerPos.y, 20 ) ) and
		   ( MAP:isWalkable( self.pos.x, self.pos.y, self.playerPos.x ) ) ) then
			hunt( self, nil ) 
		end

		if self.cooldown <= 0 then
			self.cooldown = 1.2
			shoot( self )
		end
	end

	if self.cooldown > 0 then 
		self.cooldown = self.cooldown - dt
	end
	
	-- adjust position
	go.set_position( self.pos )
end


function on_message( self, message_id, message, sender )
	if message_id == MSG_SET_PROPS then
		setup( self, message )
	end
end



