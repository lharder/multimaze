local MSG_INTERACT 			= hash( "interact" )
local MSG_REMOTE_TRIGGER	= hash( "remoteTrigger" )
local MSG_SET_PROPS 		= hash( "setProps" )

go.property( "open", false )
go.property( "locked", false )


function init( self ) 
	
	local pos = go.get_position()
	go.set_position( vmath.vector3( pos.x, pos.y + 40, pos.z ) )
	--go.set_scale( vmath.vector3( 1.2, 1.2, 1 ) )
	
	if self.open then 
		sprite.play_flipbook( "#sprite", "opened" )
	else
		sprite.play_flipbook( "#sprite", "closed" )
	end
end


function on_message( self, message_id, message, sender )
	if message_id == MSG_REMOTE_TRIGGER and not self.animating then
		if not self.locked then 
			if self.open then 
				self.animating = true
				sprite.play_flipbook( "#sprite", "close", function() 
					self.open = false
					self.animating = false
				end )
			else
				self.animating = true
				sprite.play_flipbook( "#sprite", "open", function() 
					self.open = true
					self.animating = false
				end )
			end
		end

	elseif message_id == MSG_SET_PROPS then
		self.name 	= message.name
		self.open 	= message.properties.open
		self.locked = message.properties.locked
		-- pprint( self.name .. ": " .. tostring( self.open ) )

	elseif message_id == MSG_INTERACT then
		if self.open then
			local url = msg.url( nil, message.player, "sprite" )
			go.animate( url, "tint", go.PLAYBACK_ONCE_FORWARD, vmath.vector4( 1, 1, 1, 0 ), go.EASING_LINEAR, 1, 0, function() 
				go.animate( url, "tint", go.PLAYBACK_ONCE_FORWARD, vmath.vector4( 1, 1, 1, 1 ), go.EASING_LINEAR, 1 ) 
				go.animate( url, "scale", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 1 )
			end )
			go.animate( url, "scale", go.PLAYBACK_ONCE_FORWARD, .3, go.EASING_LINEAR, 1 )
			go.animate( message.player, "position.x", go.PLAYBACK_ONCE_FORWARD, go.get_position().x, go.EASING_LINEAR, 1 )
			
		else
			pprint( "no entry for ".. message.player )
		end
		
	end
end