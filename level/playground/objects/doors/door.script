local Events = require( "level.playground.events" )

local MSG_READY_TO_INTERACT = hash( "readyToInteract" )
local MSG_INTERACT 			= hash( "interact" )
local MSG_REMOTE_TRIGGER	= hash( "remoteTrigger" )
local MSG_SET_PROPS 		= hash( "setProps" )

go.property( "open", false )
go.property( "locked", false )


function init( self ) 
	local pos = go.get_position()
	go.set_position( vmath.vector3( pos.x, pos.y + 40, pos.z ) )

	self.cntPlayersNear = 0
	
	if self.open then 
		sprite.play_flipbook( "#sprite", "opened" )
	else
		sprite.play_flipbook( "#sprite", "closed" )
	end

	if GAME:isServer() then 
		-- Allow for clients to create door objects and 
		-- assign the room to lead to as picked by the server 
		timer.delay( 2, false, function() 
			local room = ROOMMANAGER:get( self.roomid )
			if room == nil then
				room = ROOMMANAGER:select( unpack( self.roomtags:split( "," ) ) )
				ROOMMANAGER:put( self.roomid, room )
			end
			if room == nil then 
				pprint( "Error: unable to load room by given tags!" )
				return
			end

			-- broadcast the specifically selected room to all clients to set it up
			-- GlobalID is available in registry 2 secs AFTER init()!
			local gid = GAME.client.registry:getGlobalId( go.get_id() ) 
			GAME.server:sendToClients( 
				Events.newDoorSetRoom( gid, self.roomid, room.key ) 
			)
			
		end )
	end
end


local function animPlayerExit( self, playerId, sender )
	-- if the sender is the local player, then broadcast exit 
	-- to my alter ego door on the other hosts. If the sender
	-- is nil, do NOT send an exit event (again)
	if sender and sender.path == playerId then 
		pprint( "Sending door exit event to other clients" )
		
		local gid = GAME.client.registry:getGlobalId( go.get_id() ) 
		local gidPlayerId = GAME.client.registry:getGlobalId( playerId )
		local evt = Events.newObjectInteract( gid, gidPlayerId )
		GAME.client:sendToOtherClients( evt )
	end
	
	local url = msg.url( nil, playerId, "sprite" )
	go.animate( url, "tint", go.PLAYBACK_ONCE_FORWARD, vmath.vector4( 1, 1, 1, 0 ), go.EASING_LINEAR, 1, 0, function() 
		loadRoom( self.roomid, self.roomkey )
	end )
	go.animate( url, "scale", go.PLAYBACK_ONCE_FORWARD, .3, go.EASING_LINEAR, 1 )
	go.animate( playerId, "position.x", go.PLAYBACK_ONCE_FORWARD, go.get_position().x, go.EASING_LINEAR, 1 )
end


local function interact( self, message, sender )
	local player = GAME.client.registry:getClientId( message.player )
	if self.open then
		if self.cntPlayersNear == #GAME.match.proposal then 
			animPlayerExit( self, message.player, sender )		
		else
			pprint( "No way! Can't leave 'm behind!" )
		end

	else
		pprint( "no entry for ".. message.player )
	end
end


local function readyToInteract( self, message )
	if message.isReady then 
		pprint( "Now close to door: " .. message.player )
		self.cntPlayersNear = self.cntPlayersNear + 1
		if self.cntPlayersNear > #GAME.match.proposal then self.cntPlayersNear = #GAME.match.proposal end
	else 
		pprint( "No longer close to door: " .. message.player )
		self.cntPlayersNear = self.cntPlayersNear - 1
		if self.cntPlayersNear < 0 then self.cntPlayersNear = 0 end 
	end
end
	


local function parse( self, message )
	if message.meta.type == Events.DOOR_SET_ROOM then
		self.roomid 	= message.attrs.roomid
		self.roomkey 	= message.attrs.roomkey

	elseif message.meta.type == Events.OBJECT_INTERACT then
		local cid = GAME.client.registry:getClientId( message.attrs.interactWith )
		interact( self, { player = cid }, nil )

	elseif message.meta.type == Events.OBJECT_READY_TO_INTERACT then
		readyToInteract( self, message.attrs )
		
	end
end



function on_message( self, message_id, message, sender )
	if message_id == GAME.MSG_EXEC_CMD then
		parse( self, message )
		
	elseif message_id == MSG_REMOTE_TRIGGER and not self.animating then
		if not self.locked then 
			if self.open then 
				self.animating = true
				sprite.play_flipbook( "#sprite", "close", function() 
					self.open = false
					self.animating = false
				end )
			else
				self.animating = true
				sprite.play_flipbook( "#sprite", "open", function() 
					self.open = true
					self.animating = false
				end )
			end
		end

	elseif message_id == MSG_SET_PROPS then
		self.name 		= message.name
		self.open 		= message.properties.open
		self.locked 	= message.properties.locked
		self.roomid 	= message.properties.roomid
		self.roomtags 	= message.properties.roomtags
		-- pprint( self.name .. ": " .. tostring( self.open ) )

	elseif message_id == MSG_READY_TO_INTERACT then
		readyToInteract( self, message, sender )
		
	elseif message_id == MSG_INTERACT then
		interact( self, message, sender )
		
	end
end