local Events = require( "level.playground.events" )

go.property( "jumping", false )
go.property( "money", 0 )


local MSG_SET_PROPS = hash( "setProps" )
local MSG_TRIGGER_COLLISION = hash( "trigger_response" ) 


local function collect( self )
	-- Allow to collect only once! 
	-- Timing issue with multiple collision.
	self.money = 0

	-- Remove this coin
	local pos = go.get_position()
	local toPos = vmath.vector3( pos.x - 300, pos.y + 600, 0.3 )
	go.animate( ".", "position", go.PLAYBACK_ONCE_FORWARD, toPos, go.EASING_LINEAR, 1, 0, function()
		local gid = GAME.client.registry:getGlobalId( go.get_id() )
		-- possibly another instance of the coin on one of the remote
		-- hosts has already been collected and removed the gid
		if gid ~= nil then 
			local evt = Events.newDeleteObject( gid )
			GAME.client:sendToOtherClients( evt )
		end

		GAME.client.registry:remove( go.get_id() )
		go.delete()
	end )
end


local function setup( self, message )
	-- make accessible globally
	self.name = message.name
	GAME.client.registry:set( self.name, go.get_id() ) 

	if message.animname then 
		sprite.play_flipbook( "#sprite", message.animname )
	end
end


---------------
function init( self )
	if self.jumping then
		self.pos = go.get_position()
		local toPos = self.pos.y + 90
		local url = msg.url( nil, go.get_id(), "sprite" )
		go.animate( ".", "position.y", go.PLAYBACK_ONCE_FORWARD, toPos, go.EASING_OUTBOUNCE, 1 )
	end

	-- money can only be collected after it has jumped up
	-- takes one second, then value is available: state must
	-- be accessible by localplayer as well!
	timer.delay( 1, false, function() 
		self.money = 1 
	end )
end



function on_message( self, message_id, message, sender )
	if message_id == MSG_SET_PROPS then
		setup( self, message )
		
	elseif message_id == MSG_TRIGGER_COLLISION then
		if self.money > 0 then collect( self ) end
		
	end
end