local Roommanager = require( "level.playground.roommanager.roommanager" )
local Events = require( "level.playground.events" )
local Server = require( "nexus.server" )
local lua = require( "deflibs.lualib" )
local vctrl = require( "in.onscreen" )
local Tilemap = require( "level.playground.tilemap.tilemap" )

local MSG_ON_FIRST_TICK = hash( "firsttick" )



local function createVirtualCtrl( self ) 
	msg.post( "vcontroller", "register_analog", { id = "stick", radius = 60 } )
	msg.post( "vcontroller", "register_button", { id = "action" } )
	msg.post( "vcontroller", "register_button", { id = "jump" } )
end


local function createPlayer( attrs )
	local id = factory.create( attrs.factory, attrs.pos, nil, { 
		speed = attrs.speed,  
		isLocalHero = attrs.isLocalHero 
	}, 1.2 )
	label.set_text( msg.url( nil, id, "caption" ), attrs.name )

	GAME.client.registry:set( attrs.gid, id )
	
	if attrs.isLocalHero then 
		PLAYER_ID = id

		-- sync this object's pos/rot to all other clients
		GAME:sync( attrs.gid ) 
		
		-- important: user input only from the one per host / right client!
		msg.post( PLAYER_ID, "acquire_input_focus" ) 
		msg.post( "@render:", "use_fixed_fit_projection", { near = -1, far = 1 } )

		-- camera follows the local hero!
		msg.post( CAMERA_ID, "follow", {
			target = PLAYER_ID, 
			lerp = .03, 
			horizontal = true, 
			vertical = true, 
			immediate = false
		})
	end

	return id
end


local function createSyncedEntity( attrs )
	local id = factory.create( attrs.factory, attrs.pos, nil, { 
		speed = attrs.speed,
		dir = attrs.dir,  
		isLocalHero = attrs.isLocalHero
	}, .25 )
	GAME.client.registry:set( attrs.gid, id )
	
	if attrs.isLocalHero then 
		GAME:sync( attrs.gid ) 
	end

	return id
end



local function setupPlayers( roomId )
	if GAME:isServer() then 
		-- create serverside objects to run the game
		timer.delay( .5, false, function() 
			pprint( "Create level objects!" )

			-- one player for each playing host
			local j
			local startPositions = { 
				{ x = 100,  y = 180,  z = .5 },
				{ x = 800,  y = 600,  z = .5 },
				{ x = 800,  y = 100,  z = .5 },
				{ x = 100,  y = 600,  z = .5 }
			}
			for i, callsign in pairs( GAME.match.proposal ) do
				if i > #startPositions then i = 1 end
				local pos = startPositions[ i ]
				local speed = 180

				-- create one local hero on every game host / client ------------
				-- who receives and transmits input from his player to all other hosts 
				local evtLocalHero = Events.newCreatePlayer( 
					callsign, vmath.vector3( pos.x, pos.y, pos.z ), speed, callsign, true 
				)
				local host = GAME.hosts:get( callsign )
				GAME.server:send( host.ip, evtLocalHero )

				-- for all other hosts, this hero is only a drone to 
				-- be controlled by somebody somewhere else
				local evtRemoteHero = Events.newCreatePlayer( 
					callsign, vmath.vector3( pos.x, pos.y, pos.z ), speed, callsign, false 
				)
				GAME.server:sendToClientsExcept( host.ip, evtRemoteHero )

				j = i + 1
			end
		end )
	end
end



function setupRoom( id ) 
	local room = ROOMMANAGER:get( id )
	if room == nil then return end
	pprint( "Loaded room " .. room.id )

	-- map is needed for players' start positions
	MAP = Tilemap.new( "/playground#tilemap", room.data )
	setupPlayers( room.id ) 

	-- start map, create objects
	MAP:setup()
end



-- client reacts to incoming server events
local function parse( message )
	if message.meta.type == Events.CREATE_PLAYER then
		createPlayer( message.attrs )
		
	elseif message.meta.type == Events.CREATE_SYNCED_ENTITY then
		createSyncedEntity( message.attrs )

	elseif message.meta.type == Events.SELECT_ROOM then
		setupRoom( message.attrs.id )
		
	end
end



function init( self )
	createVirtualCtrl()

	if GAME:isServer() then 
		-- server: select a room by (multiple) given tags
		local room = ROOMMANAGER:select( "start", "dungeon" )
		if room == nil then 
			pprint( "Unable to load room by given tags!" )
			return 
		end

		-- broadcast selected room to all clients to set it up
		local evt = Events.newSelectRoom( room.id )
		GAME.server:sendToClients( evt )
	end
end


function on_message( self, message_id, message, sender )
	-- receive and react to serverside events
	if message_id == GAME.MSG_EXEC_CMD then
		parse( message )

	end
end


function update( self, dt )
	if GAME:isServer() then 
		GAME.server:update( dt )
	end
	if GAME.client then 
		GAME.client:update( dt )
	end
end



