local Events = require( "level.playground.events" )
local Server = require( "nexus.server" )
local Robot = require( "level.playground.characters.robot.robot" )
local lua = require( "deflibs.lualib" )
local Tilemap = require( "level.playground.tilemap.tilemap" )
local vctrl = require( "in.onscreen" )

local MSG_ON_FIRST_TICK = hash( "firsttick" )



local function createVirtualCtrl( self ) 
	msg.post( "vcontroller", "register_analog", { id = "stick", radius = 60 } )
	msg.post( "vcontroller", "register_button", { id = "action" } )
	msg.post( "vcontroller", "register_button", { id = "jump" } )
end


local function createPlayer( factoryUrl, pos, speed, txtCaption, isLocalHero )
	local id = factory.create( factoryUrl, pos, nil, { 
		speed = speed,  
		isLocalHero = isLocalHero 
	}, 1.2 )
	label.set_text( msg.url( nil, id, "caption" ), txtCaption )
	
	if isLocalHero then 
		PLAYER_ID = id
		
		-- important: user input only from the one per host / right client!
		msg.post( PLAYER_ID, "acquire_input_focus" ) 
		msg.post( "@render:", "use_fixed_fit_projection", { near = -1, far = 1 } )

		-- camera follows the local hero!
		msg.post( CAMERA_ID, "follow", {
			target = PLAYER_ID, 
			lerp = .03, 
			horizontal = true, 
			vertical = true, 
			immediate = false
		})
	end

	return id
end


local function createRobot( factoryUrl, pos, speed, txtCaption )
	local id = factory.create( factoryUrl, pos, nil, { speed = speed }, 1.2 )
	label.set_text( msg.url( nil, id, "caption" ), txtCaption )
	return id
end


local function createMap()
	local tiled = require( "assets.tiles.map" )
	MAP = Tilemap.new( "/playground#tilemap", tiled )
	MAP:render()
end



-- client reacts to incoming server events
local function parse( message )
	if message.meta.type == Events.CREATE_PLAYER then
		local id = createPlayer( 
			message.attrs.factory, 
			message.attrs.pos, 
			message.attrs.speed, 
			message.attrs.name,
			message.attrs.isLocalHero 
		)
		GAME.client.registry:set( message.attrs.gid, id )

		-- auto sync pos and rot of player (after global registry!)
		if message.attrs.isLocalHero then 
			GAME:sync( message.attrs.gid ) 
		end
		
	elseif message.meta.type == Events.CREATE_ROBOT then
		local id = createRobot( 
			message.attrs.factory, 
			message.attrs.pos, 
			message.attrs.speed, 
			message.attrs.name 
		)
		GAME.client.registry:set( message.attrs.gid, id )
	end
end


function init( self )
	GAME:start( "192.168.178.24", 15 )

	-- create serverside objects to run the game
	if GAME:isServer() then
		
		timer.delay( .5, false, function() 
			pprint( "Create level objects!" )

			-- one player for each playing host
			local j
			local startPositions = { 
				{ x = 100,  y = 100,  z = .5 },
				{ x = 800,  y = 600,  z = .5 },
				{ x = 800,  y = 100,  z = .5 },
				{ x = 100,  y = 600,  z = .5 }
			}
			for i, callsign in pairs( GAME.match.proposal ) do
				if i > #startPositions then i = 1 end
				local pos = startPositions[ i ]
				local speed = 140

				-- create one local hero on every game host / client ------------
				-- who receives and transmits input from his player to all other hosts 
				local evtLocalHero = Events.newCreatePlayer( 
					callsign, vmath.vector3( pos.x, pos.y, pos.z ), speed, callsign, true 
				)
				local host = GAME.hosts:get( callsign )
				GAME.server:send( host.ip, evtLocalHero )

				-- for all other hosts, this hero is only a drone to 
				-- be controlled by somebody somewhere else
				local evtRemoteHero = Events.newCreatePlayer( 
					callsign, vmath.vector3( pos.x, pos.y, pos.z ), speed, callsign, false 
				)
				GAME.server:sendToClientsExcept( host.ip, evtRemoteHero )

				j = i + 1
			end

			-- one robot 
			local gid = "robotA"
			local name = sprintf( "TX-%d", math.random( 10, 99 ) )
			local speed = 100
			local pos = startPositions[ j ]
			local evt = Events.newCreateRobot( gid, vmath.vector3( pos.x, pos.y, .5 ), speed, name )
			GAME.server:sendToClients( evt )

			local robot = Robot.new( gid )
			GAME.server:putBehavior( gid, robot )	

		end )
	end

	createMap()
	createVirtualCtrl()
end


function on_message( self, message_id, message, sender )
	-- receive and react to serverside events
	if message_id == GAME.MSG_EXEC_CMD then
		parse( message )
	end
end


function update( self, dt )
	if GAME:isServer() then 
		GAME.server:update( dt )
	end
	if GAME.client then 
		GAME.client:update( dt )
	end
end



