local Roommanager = require( "level.playground.roommanager.roommanager" )
local Events = require( "level.playground.events" )
local Server = require( "nexus.server" )
local lua = require( "deflibs.lualib" )
local vctrl = require( "in.onscreen" )
local Tilemap = require( "level.playground.tilemap.tilemap" )

local MSG_ON_FIRST_TICK = hash( "firsttick" )
local MSG_SCREEN_LOADED = hash( "screenmaster:loaded" ) 



local function createVirtualCtrl( self ) 
	msg.post( "vcontroller", "register_analog", { id = "stick", radius = 60 } )
	msg.post( "vcontroller", "register_button", { id = "action" } )
	msg.post( "vcontroller", "register_button", { id = "jump" } )
end


local function createPlayer( attrs )
	local id = factory.create( attrs.factory, attrs.pos, nil, { 
		speed = attrs.speed,  
		isLocalHero = attrs.isLocalHero 
	}, 1.2 )
	label.set_text( msg.url( nil, id, "caption" ), attrs.name )

	GAME.client.registry:set( attrs.gid, id )
	
	if attrs.isLocalHero then 
		PLAYER_ID = id

		-- sync this object's pos/rot to all other clients
		GAME:sync( attrs.gid ) 
		
		-- important: user input only from the one per host / right client!
		msg.post( PLAYER_ID, "acquire_input_focus" ) 
		msg.post( "@render:", "use_fixed_fit_projection", { near = -1, far = 1 } )

		-- camera follows the local hero!
		msg.post( CAMERA_ID, "follow", {
			target = PLAYER_ID, 
			lerp = .03, 
			horizontal = true, 
			vertical = true, 
			immediate = false
		})
	end

	return id
end


local function createSyncedEntity( attrs )
	local id = factory.create( attrs.factory, attrs.pos, nil, { 
		speed = attrs.speed,
		dir = attrs.dir,  
		isLocalHero = attrs.isLocalHero
	}, .25 )
	GAME.client.registry:set( attrs.gid, id )
	
	if attrs.isLocalHero then 
		GAME:sync( attrs.gid ) 
	end

	return id
end



local function setupPlayers( room )
	if GAME:isServer() then 
		-- create serverside objects to run the game
		timer.delay( .5, false, function() 
			pprint( "Create level objects!" )

			-- one player for each playing host
			for i, callsign in pairs( GAME.match.proposal ) do
				local speed = 180
				local pos = { x = 100,  y = 180,  z = .5 }

				local spawnpoint = MAP.spawnpoints[ "player0" .. i ]
				if spawnpoint == nil then 
					pprint( "Unable to find spawnpoint in map: player0" .. i ) 
				else 
					pos = vmath.vector3( spawnpoint.x, spawnpoint.y, .5 ) 
				end 
				
				-- create one local hero on every game host / client ------------
				-- who receives and transmits input from his player to all other hosts 
				local evtLocalHero = Events.newCreatePlayer( 
					callsign, vmath.vector3( pos.x, pos.y, pos.z ), speed, callsign, true 
				)
				local host = GAME.hosts:get( callsign )
				GAME.server:send( host.ip, evtLocalHero )

				-- for all other hosts, this hero is only a drone to 
				-- be controlled by somebody somewhere else
				local evtRemoteHero = Events.newCreatePlayer( 
					callsign, vmath.vector3( pos.x, pos.y, pos.z ), speed, callsign, false 
				)
				GAME.server:sendToClientsExcept( host.ip, evtRemoteHero )
			end
		end )
	end
end



function setupRoom( roomid, roomkey ) 
	local room = ROOMMANAGER:get( id )
	if room == nil then 
		room = ROOMMANAGER:room( roomkey )
		ROOMMANAGER:put( roomid, room )
	end
	pprint( "Loaded room " .. roomid )

	-- map is needed for players' start positions
	MAP = Tilemap.new( "/playground#tilemap", room )
	MAP:setup()

	setupPlayers( room ) 
end



-- client reacts to incoming server events
local function parse( message )
	if message.meta.type == Events.CREATE_PLAYER then
		createPlayer( message.attrs )
		
	elseif message.meta.type == Events.CREATE_SYNCED_ENTITY then
		createSyncedEntity( message.attrs )

	elseif message.meta.type == Events.SELECT_ROOM then
		setupRoom( message.attrs.roomid, message.attrs.roomkey )
		
	end
end



function init( self )
	createVirtualCtrl()
end


function on_message( self, message_id, message, sender )
	-- receive and react to serverside events
	if message_id == GAME.MSG_EXEC_CMD then
		parse( message )

	elseif message_id == MSG_SCREEN_LOADED then
		-- Only the server makes the selection for a new room:
		-- one of those fitting the given room tags will be selected.
		-- All clients will then receive that room's class and
		-- the id under which it is to be addressed from now on
		if GAME:isServer() then 

			local room = ROOMMANAGER:get( message.roomid )
			if room == nil then
				room = ROOMMANAGER:select( message.tags )
				ROOMMANAGER:put( message.roomid, room )
			end
			if room == nil then 
				pprint( "Error: unable to load room by given tags!" )
				return
			end
			
			-- broadcast the specifically selected room to all clients to set it up. On the
			-- clients, however, this room id does not exist yet, but it must not be randomly
			-- selected (as on the server with tags). So, send the room class's key along.
			GAME.server:sendToClients( 
				Events.newSelectRoom( message.roomid, room.key ) 
			)
		end
		
	end
end


function update( self, dt )
	if GAME:isServer() then 
		GAME.server:update( dt )
	end
	if GAME.client then 
		GAME.client:update( dt )
	end
end



