local lua = require( "deflibs.lualib" )
local Events = require( "level.jumprun.events" )

go.property( "dir", vmath.vector3( 1, 0, 0 ) )
go.property( "speed", 120 )
go.property( "isLocalHero", false )


local MODE_IDLE = 0
local IMPENETRABLE = { 29 }


local function isImpenetrable( xPix, yPix )
	return ( not MAP:isInBounds( xPix, yPix ) ) or
		lua.contains( IMPENETRABLE, MAP:getTileValue( xPix, yPix ) ) 
end


local function sendMoveTo( pos )
	local gid = GAME.client.registry:getGlobalId( go.get_id() ) 
	local evt = Events.newMoveTo( gid, pos )
	GAME.client:sendToOtherClients( evt )	
end


local function selectTargetPos( self )
	if self.isLocalHero then 
		self.targetPos = go.get_position()
		self.targetPos.x = self.targetPos.x + ( 4 * math.random( -40, 40 ) )
		self.targetPos.y = self.targetPos.y + ( 4 * math.random( -40, 40 ) )

		sendMoveTo( self.targetPos )
	end
end


local function setup( self, message ) 
	if self.isLocalHero then 
		-- make globally available and start syncing
		local gid = message.name
		local cid = go.get_id()
		GAME.client.registry:set( gid, cid )
		GAME:sync( gid ) 
	end
end


local function parse( self, message )
	if message.meta.type == Events.MOVE_TO then
		self.targetPos = message.attrs.pos
		self.dir = vmath.normalize( self.targetPos - self.pos )
	end
end




-- lifecycle methods ------------------------------
function init( self )
	go.set_scale( .5 )

	local pos = go.get_position()
	go.set_position( vmath.vector3( pos.x, pos.y, .4 ) )

	self.mode = MODE_IDLE
	self.pos = go.get_position()
	self.targetPos = go.get_position()
	selectTargetPos( self )
end


function update( self, dt ) 
	if PLAYER_ID ~= "" then 

		if self.mode == MODE_IDLE then
			self.pos = go.get_position()
			self.dir = vmath.normalize( self.targetPos - self.pos )
			self.pos.x = self.pos.x + self.dir.x * self.speed * dt
			self.pos.y = self.pos.y + self.dir.y * self.speed * dt

			sprite.set_hflip( "#sprite", self.dir.x > 0 )

			if lua.approximates( self.pos.x, self.targetPos.x, 5 ) and 
			   lua.approximates( self.pos.y, self.targetPos.y, 5 ) then
				selectTargetPos( self )
			end
		end

		if isImpenetrable( self.pos.x, self.pos.y ) then
			selectTargetPos( self )
		else
			go.set_position( self.pos )
		end
	end
	
end


function on_message( self, message_id, message, sender )
	if message_id == MSG_SET_PROPS then
		setup( self, message )

	elseif message_id == GAME.MSG_EXEC_CMD then 
		parse( self, message )
		
	end
end

