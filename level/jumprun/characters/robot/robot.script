local lua = require( "deflibs.lualib" )
local Events = require( "level.jumprun.events" )

go.property( "targetPos", vmath.vector3() )
go.property( "speed", 0 )

local MSG_ON_FIRST_TICK = hash( "firsttick" )


local function animWalk( self )
	-- change in movement?
	if self.dir ~= self.oldDir then
		local name = "standdown"

		if self.dir.y > 0 then name = "walkup" end
		if self.dir.y < 0 then name = "walkdown" end
		if self.dir.x > 0 then name = "walkright" end
		if self.dir.x < 0 then name = "walkleft" end

		-- player is standing, but used to move
		if vmath.length( self.dir ) == 0 then
			if self.oldDir.y > 0 then name = "standup" end
			if self.oldDir.y < 0 then name = "standdown" end
			if self.oldDir.x > 0 then name = "standright" end
			if self.oldDir.x < 0 then name = "standleft" end
		end	

		sprite.play_flipbook( "#sprite", name )
	end
end


local function parse( self, message )
	if message.meta.type == Events.MOVE_TO then
		if self.dir then self.oldDir = self.dir end
		self.targetPos = message.attrs.pos
		self.dir = vmath.normalize( self.targetPos - self.pos )

		animWalk( self )
	end
end



local function sendPosReached( self )
	-- send "position reached" to server
	local evt = Events.newPositionReached( self.gid, self.pos )
	-- allow for 1/2 sec to receive an answer before transmitting again
	self.nextSendTime = socket.gettime() + .5
	GAME.client:sendToServer( evt )
end


-- methods ----------------
function init( self )
	self.nextSendTime = socket.gettime()
	self.step = vmath.vector3()
	
	-- beware: go is created at this point: the registry does not know about it yet
	-- So, at this point no globalID is available yet! Takes one tick!
	-- Does NOT work: self.gid = GAME.client.registry:getGlobalId( go.get_id() )
	msg.post( ".", MSG_ON_FIRST_TICK )
end


function on_message( self, message_id, message, sender )
	if message_id == MSG_ON_FIRST_TICK then 
		-- get my global id, does not work on init()
		self.gid = GAME.client.registry:getGlobalId( go.get_id() )

	elseif message_id == GAME.MSG_EXEC_CMD then 
		parse( self, message )
	end
end


function update( self, dt )
	if self.targetPos ~= nil then
		-- Move towards target in a straight line
		self.pos = go.get_position()
		self.oldPos = self.pos

		self.dir = vmath.normalize( self.targetPos - self.pos )
		self.pos.x = self.pos.x + self.dir.x * self.speed * dt
		self.pos.y = self.pos.y + self.dir.y * self.speed * dt

		self.step.x = self.oldPos.x + self.dir.x * 32
		self.step.y = self.oldPos.y - 16 + self.dir.y * 32
		if MAP:isPassable( self.step.x, self.step.y ) then 
			go.set_position( self.pos ) 
		else
			-- actually not true, but need new target...
			sendPosReached( self )
		end
		
		-- target reached? Then inform server (and receive a new one from there)
		if 	lua.approximates( self.pos.x, self.targetPos.x, 4 ) and
			lua.approximates( self.pos.y, self.targetPos.y, 4 ) and 
			socket.gettime() > self.nextSendTime then 

			if self.gid == nil then 
				self.gid = GAME.client.registry:getGlobalId( go.get_id() )
			end

			-- get a new target from server
			sendPosReached( self )
			
			self.targetPos = nil
		end
		
	end
end

