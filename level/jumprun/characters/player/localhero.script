local Events = require( "level.jumprun.events" )
local lua = require( "deflibs.lualib" )
local vcontroller = require( "in.onscreen" )

go.property( "dir", vmath.vector3() )
go.property( "angle", vmath.vector3() )
go.property( "speed", 0 )
go.property( "isLocalHero", false )


local MSG_ON_FIRST_TICK 	= hash( "firsttick" )
local MSG_TRIGGER_COLLISION = hash( "trigger_response" ) 
local MSG_INTERACT 			= hash( "interact" )
local MSG_STICK 			= hash( "stick" )
local MSG_BTN_ACTION 		= hash( "action" )
local MSG_BTN_JUMP	 		= hash( "jump" )

local GROUP_BUTTON = hash( "button" )
local GROUP_TREASURE = hash( "treasure" )


local LEFT = hash( "key_left" )
local RIGHT = hash( "key_right" )
local UP = hash( "key_up" )
local DOWN = hash( "key_down" )
local CMD_LEFT = hash( "key_lsuper" )
local CMD_RIGHT = hash( "key_rsuper" )
local CMD_OPTION_LEFT = hash( "key_lalt" )
local CMD_OPTION_RIGHT = hash( "key_ralt" )


local function shoot( self )
	local pos = go.get_position() + self.angle * 30
	local cid = factory.create( "/factories#locallaserfactory", pos, nil, { speed = 400, dir = self.angle }, .5 )

	-- make id globally available
	local shotGid = sprintf( "%s-%d", self.gid, math.random( 0, 999999 ) )
	GAME.client.registry:set( shotGid, cid )
	
	-- inform other clients
	local evt = Events.newCreateShot( self.gid, shotGid, self.dir )
	GAME.client:sendToOtherClients( evt )

	-- keep remote shots in sync
	GAME:sync( shotGid )
end


local function interact( self )
	msg.post( self.interactWith, MSG_INTERACT )

	-- inform other clients
	local gid = GAME.client.registry:getGlobalId( self.interactWith )
	local evt = Events.newObjectInteract( gid )
	GAME.client:sendToOtherClients( evt )
end


local function animWalk( self )
	local name = "standdown"
	if not self.animating then
		
		if self.xSpeed == 0 then
			if self.dir.x > 0 then name = "standright" end
			if self.dir.x < 0 then name = "standleft" end
			if self.dir.y > 0 then name = "standup" end
			if self.dir.y < 0 then name = "standdown" end
			
		else
			self.animating = true 
			if math.abs( self.dir.x ) >= math.abs( self.dir.y ) then 
				-- x-axis movement is more significant
				if self.dir.x > 0 then name = "walkright" end
				if self.dir.x < 0 then name = "walkleft" end
			else
				-- y-axis movement is more significant
				if self.dir.y > 0 then name = "walkup" end
				if self.dir.y < 0 then name = "walkdown" end
			end
		end

		sprite.play_flipbook( "#sprite", name, function( id, tileNo ) 
			self.animating = false
		end )
		
		-- adjust camera if change of dir occurrs
		if vmath.length( self.dir ) > 0 then 
			go.set( "#playercam", "dir", self.dir )
		end
	end
end


local function jump( self )
	self.below = self.pos.y - 40
	if not MAP:isPassable( self.pos.x, self.below ) then 
		self.jumpTicks = 45
	end
end


local function vcontrol( self, action )
	self.oldDir = vmath.vector3( self.dir.x, self.dir.y, self.dir.z )

	if action.id == MSG_STICK then
		if action.released then
			self.xSpeed = 0
		else
			if( math.abs( action.x ) > 0 ) then 
				self.xSpeed = self.maxSpeed
				self.dir.x = action.x
			end

			if( math.abs( action.y ) > 0 ) then 
				-- horizontal firing is default, 
				-- clamp to exactly 0 when close
				self.angle.x = action.x
				if math.abs( action.y ) < .4 then 
					self.angle.y = 0 
				else
					self.angle.y = action.y
				end
			end
		end		
		animWalk( self )

	elseif action.id == MSG_BTN_ACTION then
		if action.pressed then self.buttons[ action.id ] = true end	
		if action.released then self.buttons[ action.id ] = false end	
		
		if self.cooldown < socket.gettime() then
			self.cooldown = socket.gettime() + .3
			
			if self.interactWith then 
				interact( self )
			else
				shoot( self )
			end
		end

	elseif action.id == MSG_BTN_JUMP then
		jump( self )
	end
end


local function calcYSpeed( x )
	return .3 * ( x * x ) 
end


-- methods ---------------------
function init( self )
	self.dir = vmath.vector3( 0, 1, 0 )
	self.oldDir = vmath.vector3()
	self.pos = go.get_position()
	self.oldPos = self.pos
	self.step = vmath.vector3()
	self.maxSpeed = self.speed
	self.xSpeed = 0
	self.ySpeed = 0
	self.jumpTicks = 0

	-- allow for change of animation only after completion
	self.animating = false

	-- prevent too many keystroke identical events
	self.cooldown = 0

	-- setup camera to follow
	go.set( "#playercam", "isLocalHero", self.isLocalHero )

	-- set me up as listener for virtual touch controller
	msg.post( "vcontroller", "register" )
	-- state of virtual buttons: pressed/not?
	self.buttons = {}

	-- provide a visual pointer for player's direction
	self.pointer = factory.create( "/factories#pointerfactory", vmath.vector3(), nil, nil, 1.2 )
	go.set_parent( self.pointer, go.get_id() )
	
	-- init this object and receive my globalId
	msg.post( ".", MSG_ON_FIRST_TICK )
end


function on_input( self, action_id, action )
	self.oldDir = vmath.vector3( self.dir.x, self.dir.y, self.dir.z )

	if( action_id == LEFT ) or ( action_id == RIGHT ) or 
	  ( action_id == UP ) or ( action_id == DOWN ) then
		if action.pressed then 
			self.dir.x = 0
			self.dir.y = 0
			self.xSpeed = self.maxSpeed
			if( action_id == LEFT ) then 
				self.dir.x = -1
			elseif( action_id == RIGHT ) then 
				self.dir.x = 1
			elseif( action_id == UP ) then 
				self.dir.y = 1
			elseif( action_id == DOWN ) then 
				self.dir.y = -1
			end
		end
		if action.released then self.xSpeed = 0 end
	end
	
	if action_id == CMD_LEFT or action_id == CMD_RIGHT then
		if self.cooldown < socket.gettime() then
			self.cooldown = socket.gettime() + .5
			
			if self.interactWith then 
				interact( self )
			else
				shoot( self )
			end
		end
	end

	if action_id == CMD_OPTION_LEFT or action_id == CMD_OPTION_RIGHT then
		jump( self )
	end

	animWalk( self )
end


function update( self, dt )
	self.oldPos = go.get_position()
	self.pos = go.get_position()
	
	self.side = self.oldPos.x + ( self.dir.x * 18 )
	self.below = self.oldPos.y - 40
	
	if self.jumpTicks > 0 then 
		-- currently jumping
		self.dir.y = 1
		self.ySpeed = calcYSpeed( self.jumpTicks )
		self.jumpTicks = self.jumpTicks - 1
		if self.jumpTicks < 0 then self.jumpTicks = 0 end

	else
		if MAP:isPassable( self.oldPos.x, self.below ) then 
			-- fall down
			self.dir.y = -1
			self.ySpeed = 250
		else
			self.ySpeed = 0
		end
	end

	if not MAP:isPassable( self.pos.x, self.pos.y - 20 ) and 
	   self.jumpTicks == 0 then 
		-- standing in(!) an obstacle: may happen after 
		-- jumps that have not reached the top of a platform.
		-- In that case: fall down again
		self.dir.y = -1
		self.ySpeed = 250
	end

	if not MAP:isPassable( self.side, self.oldPos.y ) then 
		-- x movement is blocked by obstacle
		self.dir.x = 0
	end

	self.pos.x = self.oldPos.x + self.dir.x * self.xSpeed * dt
	self.pos.y = self.oldPos.y + self.dir.y * self.ySpeed * dt
	go.set_position( self.pos ) 

end


function on_message( self, message_id, message, sender )
	if message_id == MSG_ON_FIRST_TICK then 
		-- get my global id, does not work on init()
		-- cannot pass in string params on factory.create...
		self.gid = GAME.client.registry:getGlobalId( go.get_id() )

	elseif message_id == MSG_TRIGGER_COLLISION then
		if( message.other_group == GROUP_BUTTON ) or 
		  ( message.other_group == GROUP_TREASURE ) then
			if message.enter then
				self.interactWith = message.other_id
			else
				self.interactWith = nil
			end
		end

	elseif message_id == GAME.MSG_EXEC_CMD then 
		parse( self, message )

	elseif 	( message_id == vcontroller.ANALOG ) or 
			( message_id == vcontroller.BUTTON ) then 
		vcontrol( self, message )
		
	end
end



